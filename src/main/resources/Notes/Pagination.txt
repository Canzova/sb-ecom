ğŸ”¥ COMPLETE GUIDE TO PAGINATION IN SPRING BOOT ğŸ”¥
=================================================

ğŸ’¡ What This Code Does
----------------------
Pageable pageDetails = PageRequest.of(pageNumber, pageSize);
Page<Category> categoryPage = categoryRepository.findAll(pageDetails);
List<Category> allCategories = categoryPage.getContent();

ğŸ‘‰ This code is implementing PAGINATION â€” fetching limited data (a "page") instead of loading everything.

------------------------------------------------------------

ğŸ“˜ WHY USE PAGINATION?
----------------------
Imagine you have 10,000 records. Loading all of them = âŒ slow, âŒ memory heavy.

Pagination lets you say:
â¡ï¸ â€œGive me only 10 results from page 2.â€

Result = âœ… Faster, âœ… Efficient, âœ… Scalable APIs.

------------------------------------------------------------

âš™ï¸ MAIN CONCEPTS
================

1ï¸âƒ£ Pageable
-------------
ğŸ“– What: An INTERFACE that tells Spring which page and how many records you want.
ğŸ“¦ Import:  org.springframework.data.domain.Pageable
ğŸ’¬ You donâ€™t create it directly â€” use PageRequest instead.

Example:
    Pageable pageable = PageRequest.of(0, 5);
    // Page 0 (first page), 5 records per page

------------------------------------------------------------

2ï¸âƒ£ PageRequest
----------------
ğŸ“– What: A CLASS that implements Pageable.
ğŸ“¦ Import:  org.springframework.data.domain.PageRequest
ğŸ’¡ Created using a static method `of(pageNumber, pageSize)`.

Example:
    Pageable pageable = PageRequest.of(1, 10);
    // Page 1, 10 records per page

You can also add sorting (see later ğŸ‘‡).

------------------------------------------------------------

3ï¸âƒ£ Page<T>
------------
ğŸ“– What: A WRAPPER object that contains both:
   - âœ… The list of data
   - ğŸ“Š Extra info like total pages, total records, etc.

ğŸ“¦ Import: org.springframework.data.domain.Page

Example:
    Page<Category> categoryPage = categoryRepository.findAll(pageable);
    List<Category> categories = categoryPage.getContent();
    long total = categoryPage.getTotalElements();
    int pages = categoryPage.getTotalPages();

------------------------------------------------------------

ğŸ§© STEP-BY-STEP EXPLANATION
===========================

1ï¸âƒ£ Pageable pageDetails = PageRequest.of(pageNumber, pageSize);
   â¤ Tells Spring: which page & how many items to fetch.

2ï¸âƒ£ Page<Category> categoryPage = categoryRepository.findAll(pageDetails);
   â¤ Uses Spring Data JPA to get a "page" of data.

3ï¸âƒ£ List<Category> allCategories = categoryPage.getContent();
   â¤ Extracts the actual data list from the Page object.

------------------------------------------------------------

ğŸ“¦ CORRECT IMPORTS
==================
âœ… Use these:
   import org.springframework.data.domain.Page;
   import org.springframework.data.domain.Pageable;
   import org.springframework.data.domain.PageRequest;

ğŸš« Avoid these:
   java.awt.print.Pageable      âŒ
   javax.swing.text.html.Page   âŒ

------------------------------------------------------------


ğŸ§  HOW PAGINATION WORKS INTERNALLY IN THE DATABASE
=================================================

When you call:
    Page<Category> categoryPage = categoryRepository.findAll(pageable);

Spring Data JPA automatically translates this into a **SQL query** with
LIMIT and OFFSET (or equivalent keywords, depending on your database).

For example, if you request:
    PageRequest.of(1, 5);

ğŸ‘‰ Spring will calculate:
   OFFSET = pageNumber * pageSize = 1 * 5 = 5
   LIMIT = pageSize = 5

So the SQL query generated might look like:

    SELECT * FROM categories LIMIT 5 OFFSET 5;

This means:
â¡ï¸ Skip the first 5 rows (OFFSET)
â¡ï¸ Then fetch the next 5 rows (LIMIT)

ğŸ’¡ Internally, the database fetches *only* the records needed for that page.
Spring Data JPA also fires another count query to know the total number of records:

    SELECT COUNT(*) FROM categories;

This second query helps it calculate:
- total elements (rows)
- total pages

So you can use methods like getTotalElements() and getTotalPages() easily.

âœ… Efficient
âœ… Automatic
âœ… Database independent (works with MySQL, PostgreSQL, etc.)

------------------------------------------------------------


ğŸ§  FULL CONTROLLER EXAMPLE
==========================

@RestController
@RequestMapping("/categories")
public class CategoryController {

    @Autowired
    private CategoryRepository categoryRepository;

    @GetMapping
    public List<Category> getAllCategories(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "5") int size
    ) {
        Pageable pageable = PageRequest.of(page, size);
        Page<Category> categoryPage = categoryRepository.findAll(pageable);
        return categoryPage.getContent();
    }
}

ğŸŒ Example URL:
    http://localhost:8080/categories?page=1&size=5

Meaning:
â¡ï¸ Page 1 (2nd page, since it starts from 0)
â¡ï¸ 5 records per page

------------------------------------------------------------

ğŸ§¾ VARIATIONS OF PageRequest
============================

âœ¨ BASIC
--------
PageRequest.of(pageNumber, pageSize);

âœ¨ WITH SORTING (ASCENDING)
---------------------------
PageRequest.of(pageNumber, pageSize, Sort.by("fieldName"));

âœ¨ WITH SORTING (DESCENDING)
----------------------------
PageRequest.of(pageNumber, pageSize, Sort.by(Sort.Direction.DESC, "createdDate"));

------------------------------------------------------------

ğŸ“Š USEFUL METHODS OF Page
=========================
Method                    | Description
------------------------------------------------------------
getContent()              | Returns list of entities
getNumber()               | Returns current page number
getSize()                 | Returns page size
getTotalPages()           | Returns total number of pages
getTotalElements()        | Returns total records count
hasNext()                 | True if thereâ€™s another page
isFirst()                 | True if itâ€™s the first page

------------------------------------------------------------

ğŸš€ WHY USE PAGINATION
=====================
âœ… Improves performance
âœ… Reduces memory usage
âœ… Faster API responses
âœ… User-friendly for front-end apps
âœ… Standard practice for REST APIs

------------------------------------------------------------

ğŸ”§ ADVANCED EXAMPLE (WITH SORTING)
==================================

@GetMapping("/categories")
public Page<Category> getCategories(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "5") int size,
    @RequestParam(defaultValue = "id") String sortBy
) {
    Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy).ascending());
    return categoryRepository.findAll(pageable);
}

Example URL:
    http://localhost:8080/categories?page=0&size=5&sortBy=name

JSON Output Example:
{
  "content": [ ... list of categories ... ],
  "totalPages": 10,
  "totalElements": 50,
  "size": 5,
  "number": 0
}

------------------------------------------------------------

ğŸ“‹ SUMMARY TABLE
================

Concept       | Type        | Purpose                       | Import Path
---------------------------------------------------------------------------
Pageable      | Interface   | Defines which page to fetch    | org.springframework.data.domain.Pageable
PageRequest   | Class       | Creates Pageable instances     | org.springframework.data.domain.PageRequest
Page<T>       | Interface   | Holds page data & info         | org.springframework.data.domain.Page

------------------------------------------------------------

âœ… TL;DR (IN ONE LINE)
======================
ğŸ§© Pageable â†’ defines which page to fetch
ğŸ§© PageRequest â†’ creates the Pageable
ğŸ§© Page â†’ contains the paged results

------------------------------------------------------------

ğŸ QUICK MEMORY TIP
===================
@RequestParam â†’ get data from URL or form
@PathVariable â†’ get data from URL path
@RequestBody â†’ get data from JSON body
@ModelAttribute â†’ get form data mapped to an object

------------------------------------------------------------

ğŸ¯ FINAL TAKEAWAY
=================
"Use Pageable and PageRequest to control how much data is fetched
from the database, improve performance, and build professional paginated APIs."

ğŸš€ Now you can confidently implement pagination in any Spring Boot project!
