🔥 COMPLETE GUIDE TO PAGINATION IN SPRING BOOT 🔥
=================================================

💡 What This Code Does
----------------------
Pageable pageDetails = PageRequest.of(pageNumber, pageSize);
Page<Category> categoryPage = categoryRepository.findAll(pageDetails);
List<Category> allCategories = categoryPage.getContent();

👉 This code is implementing PAGINATION — fetching limited data (a "page") instead of loading everything.

------------------------------------------------------------

📘 WHY USE PAGINATION?
----------------------
Imagine you have 10,000 records. Loading all of them = ❌ slow, ❌ memory heavy.

Pagination lets you say:
➡️ “Give me only 10 results from page 2.”

Result = ✅ Faster, ✅ Efficient, ✅ Scalable APIs.

------------------------------------------------------------

⚙️ MAIN CONCEPTS
================

1️⃣ Pageable
-------------
📖 What: An INTERFACE that tells Spring which page and how many records you want.
📦 Import:  org.springframework.data.domain.Pageable
💬 You don’t create it directly — use PageRequest instead.

Example:
    Pageable pageable = PageRequest.of(0, 5);
    // Page 0 (first page), 5 records per page

------------------------------------------------------------

2️⃣ PageRequest
----------------
📖 What: A CLASS that implements Pageable.
📦 Import:  org.springframework.data.domain.PageRequest
💡 Created using a static method `of(pageNumber, pageSize)`.

Example:
    Pageable pageable = PageRequest.of(1, 10);
    // Page 1, 10 records per page

You can also add sorting (see later 👇).

------------------------------------------------------------

3️⃣ Page<T>
------------
📖 What: A WRAPPER object that contains both:
   - ✅ The list of data
   - 📊 Extra info like total pages, total records, etc.

📦 Import: org.springframework.data.domain.Page

Example:
    Page<Category> categoryPage = categoryRepository.findAll(pageable);
    List<Category> categories = categoryPage.getContent();
    long total = categoryPage.getTotalElements();
    int pages = categoryPage.getTotalPages();

------------------------------------------------------------

🧩 STEP-BY-STEP EXPLANATION
===========================

1️⃣ Pageable pageDetails = PageRequest.of(pageNumber, pageSize);
   ➤ Tells Spring: which page & how many items to fetch.

2️⃣ Page<Category> categoryPage = categoryRepository.findAll(pageDetails);
   ➤ Uses Spring Data JPA to get a "page" of data.

3️⃣ List<Category> allCategories = categoryPage.getContent();
   ➤ Extracts the actual data list from the Page object.

------------------------------------------------------------

📦 CORRECT IMPORTS
==================
✅ Use these:
   import org.springframework.data.domain.Page;
   import org.springframework.data.domain.Pageable;
   import org.springframework.data.domain.PageRequest;

🚫 Avoid these:
   java.awt.print.Pageable      ❌
   javax.swing.text.html.Page   ❌

------------------------------------------------------------


🧠 HOW PAGINATION WORKS INTERNALLY IN THE DATABASE
=================================================

When you call:
    Page<Category> categoryPage = categoryRepository.findAll(pageable);

Spring Data JPA automatically translates this into a **SQL query** with
LIMIT and OFFSET (or equivalent keywords, depending on your database).

For example, if you request:
    PageRequest.of(1, 5);

👉 Spring will calculate:
   OFFSET = pageNumber * pageSize = 1 * 5 = 5
   LIMIT = pageSize = 5

So the SQL query generated might look like:

    SELECT * FROM categories LIMIT 5 OFFSET 5;

This means:
➡️ Skip the first 5 rows (OFFSET)
➡️ Then fetch the next 5 rows (LIMIT)

💡 Internally, the database fetches *only* the records needed for that page.
Spring Data JPA also fires another count query to know the total number of records:

    SELECT COUNT(*) FROM categories;

This second query helps it calculate:
- total elements (rows)
- total pages

So you can use methods like getTotalElements() and getTotalPages() easily.

✅ Efficient
✅ Automatic
✅ Database independent (works with MySQL, PostgreSQL, etc.)

------------------------------------------------------------


🧠 FULL CONTROLLER EXAMPLE
==========================

@RestController
@RequestMapping("/categories")
public class CategoryController {

    @Autowired
    private CategoryRepository categoryRepository;

    @GetMapping
    public List<Category> getAllCategories(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "5") int size
    ) {
        Pageable pageable = PageRequest.of(page, size);
        Page<Category> categoryPage = categoryRepository.findAll(pageable);
        return categoryPage.getContent();
    }
}

🌐 Example URL:
    http://localhost:8080/categories?page=1&size=5

Meaning:
➡️ Page 1 (2nd page, since it starts from 0)
➡️ 5 records per page

------------------------------------------------------------

🧾 VARIATIONS OF PageRequest
============================

✨ BASIC
--------
PageRequest.of(pageNumber, pageSize);

✨ WITH SORTING (ASCENDING)
---------------------------
PageRequest.of(pageNumber, pageSize, Sort.by("fieldName"));

✨ WITH SORTING (DESCENDING)
----------------------------
PageRequest.of(pageNumber, pageSize, Sort.by(Sort.Direction.DESC, "createdDate"));

------------------------------------------------------------

📊 USEFUL METHODS OF Page
=========================
Method                    | Description
------------------------------------------------------------
getContent()              | Returns list of entities
getNumber()               | Returns current page number
getSize()                 | Returns page size
getTotalPages()           | Returns total number of pages
getTotalElements()        | Returns total records count
hasNext()                 | True if there’s another page
isFirst()                 | True if it’s the first page

------------------------------------------------------------

🚀 WHY USE PAGINATION
=====================
✅ Improves performance
✅ Reduces memory usage
✅ Faster API responses
✅ User-friendly for front-end apps
✅ Standard practice for REST APIs

------------------------------------------------------------

🔧 ADVANCED EXAMPLE (WITH SORTING)
==================================

@GetMapping("/categories")
public Page<Category> getCategories(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "5") int size,
    @RequestParam(defaultValue = "id") String sortBy
) {
    Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy).ascending());
    return categoryRepository.findAll(pageable);
}

Example URL:
    http://localhost:8080/categories?page=0&size=5&sortBy=name

JSON Output Example:
{
  "content": [ ... list of categories ... ],
  "totalPages": 10,
  "totalElements": 50,
  "size": 5,
  "number": 0
}

------------------------------------------------------------

📋 SUMMARY TABLE
================

Concept       | Type        | Purpose                       | Import Path
---------------------------------------------------------------------------
Pageable      | Interface   | Defines which page to fetch    | org.springframework.data.domain.Pageable
PageRequest   | Class       | Creates Pageable instances     | org.springframework.data.domain.PageRequest
Page<T>       | Interface   | Holds page data & info         | org.springframework.data.domain.Page

------------------------------------------------------------

✅ TL;DR (IN ONE LINE)
======================
🧩 Pageable → defines which page to fetch
🧩 PageRequest → creates the Pageable
🧩 Page → contains the paged results

------------------------------------------------------------

🏁 QUICK MEMORY TIP
===================
@RequestParam → get data from URL or form
@PathVariable → get data from URL path
@RequestBody → get data from JSON body
@ModelAttribute → get form data mapped to an object

------------------------------------------------------------

🎯 FINAL TAKEAWAY
=================
"Use Pageable and PageRequest to control how much data is fetched
from the database, improve performance, and build professional paginated APIs."

🚀 Now you can confidently implement pagination in any Spring Boot project!
