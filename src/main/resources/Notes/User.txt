â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ§  EXPLANATION OF ENUM, @ENUMERATED, AND CONSTRUCTORS IN JPA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1ï¸âƒ£ WHY WE ARE USING ENUM â“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Purpose:
An enum (short for "enumeration") defines a fixed set of constant values.
Itâ€™s used when you have a known list of valid options â€” for example, user roles.

Using an enum:
- Prevents invalid values (compile-time safety)
- Makes code more readable and maintainable
- Ensures only valid, predefined constants are used

Example:
------------------------------------------------
public enum AppRole {
    ROLE_USER,
    ROLE_SELLER,
    ROLE_ADMIN
}
------------------------------------------------

Here, each Role in the system can only have one of these three values.


2ï¸âƒ£ WHY WE ARE USING @ENUMERATED â“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
When saving enums to a database, JPA needs to know *how* to store them.

Options:
- EnumType.ORDINAL â†’ Stores the enumâ€™s numeric index (0,1,2,...)
  âŒ Risky, because changing enum order breaks data consistency
- EnumType.STRING â†’ Stores the enumâ€™s name ("ROLE_USER", etc.)
  âœ… Safer and human-readable

Example:
------------------------------------------------
@Enumerated(EnumType.STRING)
@Column(length = 20, name = "role_name")
private AppRole roleName;
------------------------------------------------
â†’ This saves "ROLE_USER" in the database, not 0.


3ï¸âƒ£ WHY WE HAVE CONSTRUCTORS WITHOUT ID â“
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
The @Id field is auto-generated by the database (due to @GeneratedValue).

So:
- When creating new objects, we donâ€™t set the ID manually.
- We provide constructors only for fields users set themselves.
- JPA also requires a no-argument constructor for internal use.

Example:
------------------------------------------------
public User(String userName, String email, String password) {
    this.userName = userName;
    this.email = email;
    this.password = password;
}
------------------------------------------------
When saved, the database automatically generates userId.

âœ… Summary Table
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
| Concept                    | Purpose / Explanation                              |
|-----------------------------|----------------------------------------------------|
| Enum                        | Defines fixed constant values                      |
| @Enumerated(EnumType.STRING)| Stores enums as readable text                      |
| Constructor w/o ID          | For object creation (ID auto-generated)            |
| @NoArgsConstructor          | Required by JPA for reflection                     |

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš™ï¸ WHY CUSTOM CONSTRUCTORS EVEN WITH @DATA & @ALLARGS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§© What Lombok Does
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@Data â†’ Generates:
- Getters, setters
- toString(), equals(), hashCode()
- A requiredArgsConstructor (only if fields are final or @NonNull)

@AllArgsConstructor â†’ Generates a constructor with *all* fields (including ID)

@NoArgsConstructor â†’ Generates a no-arg constructor (needed for JPA)


ğŸ§± WHY CUSTOM CONSTRUCTOR (WITHOUT ID)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Because:
- @AllArgsConstructor includes the ID field
- But in JPA, IDs are generated automatically
- We donâ€™t want to manually set them when creating a new entity

So we create our own constructor *without ID*:

Example:
------------------------------------------------
public User(String userName, String email, String password) {
    this.userName = userName;
    this.email = email;
    this.password = password;
}
------------------------------------------------

Then we can do:
User user = new User("John", "john@gmail.com", "12345");
â†’ The database assigns the ID automatically.


âœ… Summary
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
| Annotation / Constructor | Purpose |
|---------------------------|----------|
| @NoArgsConstructor        | Needed by JPA (reflection) |
| @AllArgsConstructor       | For full initialization (includes ID) |
| Custom constructor        | For new entities before saving |
| @Data                     | Generates getters/setters & utility methods |

ğŸ’¡ TL;DR:
We add our own constructor without ID because Lombokâ€™s @AllArgsConstructor includes it â€”
and IDs should be generated by the database, not manually assigned.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“˜ END OF NOTES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
