â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ§  SPRING SECURITY USERDETAILS EXPLAINED (BEGINNER FRIENDLY)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§© 1ï¸âƒ£ WHY DO WE IMPLEMENT (NOT EXTEND) `UserDetails`?
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

âœ… `UserDetails` is an INTERFACE from Spring Security that defines
what Spring needs to know about a user when logging in.

                OR

âœ… `UserDetails` is an INTERFACE which represents a user. This is like how Spring security sees a user

It looks roughly like this:

    public interface UserDetails {
        String getUsername();
        String getPassword();
        Collection<? extends GrantedAuthority> getAuthorities();
        boolean isAccountNonExpired();
        boolean isAccountNonLocked();
        boolean isCredentialsNonExpired();
        boolean isEnabled();
    }

Spring only understands objects that implement this interface.

ğŸ’¡ So what do we do?

We already have our own `User` entity from the database
(with `email`, `roles`, etc.),
but Spring wants a `UserDetails` object.

ğŸ‘‰ So, we create our own class â†’ `UserDetailsImpl`
that wraps our `User` and presents it in a format Spring understands.

Think of it like a ğŸ—£ï¸ **translator**
between your database User and Spring Security.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ§  What about `UserDetailsService`?

`UserDetailsService` is another interface that Spring uses
to load the user from the database (by username or email).

Inside it, you write logic to fetch your user
and convert it into a `UserDetailsImpl` object.

Example:

    @Service
    public class UserDetailsServiceImpl implements UserDetailsService {
        @Autowired
        UserRepository userRepository;

        @Override
        public UserDetails loadUserByUsername(String username)
                throws UsernameNotFoundException {

            User user = userRepository.findByUserName(username)
                    .orElseThrow(() -> new UsernameNotFoundException("User not found"));

            // âœ… Getting the user from UserDetailsImp.build() method
            return UserDetailsImpl.build(user);
        }
    }

âœ… So:
- `UserDetailsService` â†’ loads user from DB
- `UserDetailsImpl` â†’ adapts that user into a form Spring Security can use

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§© 2ï¸âƒ£ `private Collection<? extends GrantedAuthority> authorities`
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

This might look scary, but itâ€™s simple ğŸ˜„

Meaning:

- `Collection` â†’ means itâ€™s a list-like structure
- `? extends GrantedAuthority` â†’ means the list can hold any type of object
  that IS A CHILD OF `GrantedAuthority`

ğŸ’¬ What is a `GrantedAuthority`?

Itâ€™s an interface that represents a userâ€™s permission or role.

Example:

    new SimpleGrantedAuthority("ROLE_ADMIN")

This means the user has the ADMIN role.

So:
    Collection<? extends GrantedAuthority> authorities

literally means:

> â€œA list of all the roles or permissions this user has.â€

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§© 3ï¸âƒ£ The `build(User user)` Method
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Youâ€™re right â€” it returns a new `UserDetailsImpl` object
built from a `User` entity.

Even if you donâ€™t call it manually,
ğŸ‘‰ it gets called automatically inside your `UserDetailsServiceImpl`.

Example:

    return UserDetailsImpl.build(user);

Thatâ€™s where itâ€™s used â€” right before returning to Spring Security.

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ’¡ What does this line do?

    List<GrantedAuthority> authorities1 = user.getRoles().stream()
        .map(role -> new SimpleGrantedAuthority(role.getRoleName().name()))
        .collect(Collectors.toList());

Letâ€™s decode it step by step ğŸª„

1ï¸âƒ£ `user.getRoles()` â†’ gives you a list of Role entities
2ï¸âƒ£ `.map(...)` â†’ converts each Role into a `SimpleGrantedAuthority` object
3ï¸âƒ£ `.collect(...)` â†’ turns the stream back into a List

âœ… SimpleGrantedAuthority is the class which implements GrantedAuthority interface

So, if your user has `[ROLE_USER, ROLE_ADMIN]`,
this becomes:

    [
        new SimpleGrantedAuthority("ROLE_USER"),
        new SimpleGrantedAuthority("ROLE_ADMIN")
    ]

âœ… This is how Spring knows what roles the user has
for authorization checks like:

    @PreAuthorize("hasRole('ADMIN')")

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§© 4ï¸âƒ£ The `equals()` Method
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

This one confuses everyone at first ğŸ˜…
Letâ€™s simplify ğŸ‘‡

ğŸ§  What does `equals()` normally do?

When you write:

    user1.equals(user2);

By default, Java checks if both variables point to the same memory address.
But we often want to check if they represent the same USER.

ğŸ’¡ So we override it:

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;                      // same object in memory: 2 reference vars pointing to same user
        if (o == null || getClass() != o.getClass()) return false; // getClass() will give the class of current class

        UserDetailsImpl user = (UserDetailsImpl) o;
        return Objects.equals(id, user.id);              // same database ID = same user
    }

Now:

âœ… Two different `UserDetailsImpl` objects with the same `id`
   are treated as equal.

âœ… Useful when Spring keeps track of logged-in users in memory.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ TL;DR SUMMARY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

| Concept               | What It Does                                   | Analogy                  |
|------------------------|------------------------------------------------|---------------------------|
| `UserDetails`          | Springâ€™s user information format               | A "user template"         |
| `UserDetailsImpl`      | Converts your User entity to Springâ€™s format   | Translator                |
| `UserDetailsService`   | Loads user from DB and returns UserDetails     | Data Fetcher              |
| `GrantedAuthority`     | Represents a role/permission                   | Role card (â€œAdminâ€)       |
| `SimpleGrantedAuthority` | Concrete class for GrantedAuthority          | Simple role label         |
| `equals()` override    | Checks if two users are the same by ID         | â€œAre you the same person?â€|

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
