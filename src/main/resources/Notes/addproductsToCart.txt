============================================================
‚≠ê SUPER SIMPLE EXPLANATION OF THE ENTIRE addToCart METHOD
============================================================

Imagine this method as a cashier adding a product to a
customer‚Äôs shopping cart in an online store.
Below is the simplest possible breakdown of every step.

============================================================
‚úî STEP 1: Check if product already exists in the user's cart
============================================================

Code:
------------------------------------------------------------
CartItem cartItem = cartItemRepository
        .findCartItemByProductIdAndCartId(productId, cart.getCartId());

if(cartItem != null){
    throw new APIException("Product already exists in cart");
}
------------------------------------------------------------

Meaning:
- Check the database: "Is this product already in this user's cart?"
- If yes ‚Üí STOP and throw: "Product already exists in cart".

Prevents adding the same product twice.

============================================================
‚úî STEP 2: Check product stock availability
============================================================

‚ö† Check if stock is zero:
------------------------------------------------------------
if(product.getQuantity() == 0)
    throw new APIException("Product is not available");
------------------------------------------------------------

Meaning:
- If store stock is 0 ‚Üí product is unavailable ‚Üí stop.

‚ö† Check if user wants more than available:
------------------------------------------------------------
if(product.getQuantity() < quantity)
    throw new APIException("Please order less or equal to available quantity.");
------------------------------------------------------------

Example:
Store has 5 pieces
User tries to add 8 ‚Üí ‚ùå Not allowed.

============================================================
‚úî STEP 3: Create a new CartItem and fill its details
============================================================

Code:
------------------------------------------------------------
CartItem newCartItem = new CartItem();
newCartItem.setProduct(product);
newCartItem.setCart(cart);
newCartItem.setQuantity(quantity);
newCartItem.setDiscount(product.getDiscount());
newCartItem.setProductPrice(product.getSpecialPrice());

cartItemRepository.save(newCartItem);
------------------------------------------------------------

Meaning:
We create a new cart row with:
- The selected product
- How many the user added
- Discount
- Final price

Then we save it in the database.

============================================================
‚úî STEP 4: Update the cart total price
============================================================

Code:
------------------------------------------------------------
cart.setTotalPrice(
    cart.getTotalPrice() + (product.getSpecialPrice() * quantity)
);
cartRepository.save(cart);
------------------------------------------------------------

Meaning:
Increase total cart price by:
(product special price √ó quantity)

Example:
Price = 100
Quantity = 2
Add 200 to the cart total.

============================================================
‚úî STEP 5: Convert Cart ‚Üí CartDTO
============================================================

Code:
------------------------------------------------------------
CartDTO cartDTO = modelMapper.map(cart, CartDTO.class);
------------------------------------------------------------

Meaning:
CartDTO is returned to the client as a clean JSON response.

============================================================
‚úî STEP 6: Convert each CartItem into ProductDTO
============================================================

Code:
------------------------------------------------------------
List<CartItem> cartItems = cart.getCartItem();

Stream<ProductDTO> productDtoList = cartItems.stream()
    .map(item -> {
        ProductDTO map = modelMapper.map(item.getProduct(), ProductDTO.class);
        map.setQuantity(item.getQuantity());
        return map;
    });

cartDTO.setProducts(productDtoList.toList());
------------------------------------------------------------

‚≠ê Simplest explanation:
For every cart item:
1. Take the product
2. Convert it into ProductDTO
3. Replace the ProductDTO quantity with the cart item quantity

Why?
- product.getQuantity() = store stock
- item.getQuantity() = quantity user added

We need to show the **cart quantity**, not the store quantity.

We collect all DTOs and put them in cartDTO.

For more detail, scroll down.

============================================================
‚úî STEP 7: Return the final CartDTO
============================================================

Code:
------------------------------------------------------------
return cartDTO;
------------------------------------------------------------

CartDTO now contains:
- cartId
- totalPrice
- list of products with the correct quantities added by the user

This is sent back to the frontend.

============================================================
üéØ FINAL SUMMARY (ULTRA SIMPLE)
============================================================

The method performs:

1. Check if product already exists ‚Üí stop if yes
2. Check stock ‚Üí stop if insufficient
3. Create a new CartItem
4. Save it to the database
5. Update the cart total price
6. Convert the cart to a DTO
7. Convert each cart item into ProductDTO
8. Override DTO quantity with cart quantity
9. Return the full cart DTO

============================================================

============================================================
üß† WHY DO WE CONVERT PRODUCT ‚Üí PRODUCTDTO IN THE CART?
============================================================

‚≠ê REASON 1: The cart needs to show PRODUCTS, not cart items.
------------------------------------------------------------
When a user opens their cart, they expect to see:
- Product name
- Product price
- Product image
- Product discount
- Quantity added

These are PRODUCT details.
So we return ProductDTO inside the CartDTO.

------------------------------------------------------------
‚≠ê REASON 2: ProductDTO is what the frontend understands
------------------------------------------------------------
The frontend UI knows how to render product details.
It does NOT need:
- cartId
- cartItemId
- cart reference

Those are backend/internal details.

------------------------------------------------------------
‚≠ê REASON 3: Only quantity is needed from CartItem
------------------------------------------------------------
CartItem contains:
(cart, product, discount, productPrice, quantity)

But the only useful thing for the cart UI is:
üëâ quantity user added

So we take:
- Product info from product
- Quantity from cart item
Combine them into ProductDTO.

------------------------------------------------------------
‚úÖ FINAL ANSWER FOR QUESTION 1
------------------------------------------------------------
We convert products into ProductDTO because the cart displays
product information, NOT cart-item technical fields.
ProductDTO + quantity = perfect for cart display.


============================================================
üß† WHY DON'T WE CREATE CartItemDTO AND RETURN THAT INSTEAD?
============================================================

------------------------------------------------------------
‚≠ê REASON 1: CartItemDTO would be mostly unnecessary
------------------------------------------------------------
CartItem fields:
- cartItemId ‚ùå not needed
- cart ‚ùå not needed
- product ‚úî needed
- quantity ‚úî needed
- price/discount ‚úî already present in ProductDTO

A CartItemDTO would basically look like:
{
  product: ProductDTO,
  quantity: number
}

But we ALREADY do this by setting quantity inside ProductDTO.

So CartItemDTO becomes redundant.

------------------------------------------------------------
‚≠ê REASON 2: ProductDTO already contains everything needed
------------------------------------------------------------
When we do:

map.setQuantity(item.getQuantity());

We are effectively creating:
Product (as user sees in cart) + quantity user selected

CartItemDTO doesn't add anything new.

------------------------------------------------------------
‚≠ê REASON 3: Simpler API Response
------------------------------------------------------------
Much cleaner to return:

{
  cartId: 1,
  totalPrice: 2000,
  products: [
    { product details..., quantity: 2 }
  ]
}

Instead of:

{
  cartId: 1,
  totalPrice: 2000,
  cartItems: [
    {
      cartItemId: 10,
      cart: {...},
      product: {...},
      quantity: 2,
      discount: 10,
      productPrice: 500
    }
  ]
}

The second response is cluttered with backend details.

------------------------------------------------------------
‚úÖ FINAL ANSWER FOR QUESTION 2
------------------------------------------------------------
We don‚Äôt use CartItemDTO because it creates unnecessary
complexity. Everything needed (product info + quantity)
is already combined inside ProductDTO. No need for another DTO.


============================================================
üéØ SUPER SHORT SUMMARY
============================================================
üìå Cart displays PRODUCTS ‚Üí so we return ProductDTO.
üìå Only thing needed from CartItem ‚Üí quantity.
üìå CartItemDTO = unnecessary extra class.
üìå ProductDTO + quantity = perfect, simple, clean cart response.

============================================================
