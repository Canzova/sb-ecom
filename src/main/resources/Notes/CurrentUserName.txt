â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘            ğŸª JWT IN COOKIES â€” HOW SPRING SECURITY HANDLES IT            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸŒ **1. JWT Stored in Cookie â†’ How Spring Knows the User**
----------------------------------------------------------------------------

Even when using cookies instead of Authorization headers, the flow is the same:

ğŸ“Œ **Browser automatically sends cookies with every request**
Example:
    Cookie: jwt=<your-jwt-token>

ğŸ“Œ **Your AuthTokenFilter reads the JWT from the cookie**
    String jwt = jwtUtils.getJwtFromHeader(request);

ğŸ“Œ **Then:**
1. Validate JWT
2. Load user from DB/UserDetailsService
3. Create Authentication object
4. Place it inside SecurityContext

    SecurityContextHolder.getContext().setAuthentication(authentication);

â¡ï¸ **Only after this, Spring knows the user for THAT request.**

----------------------------------------------------------------------------

ğŸ”¥ **2. Why does the controller receive the Authentication object automatically?**
----------------------------------------------------------------------------

Because your filter put the Authentication object into the SecurityContext:

    SecurityContextHolder.getContext().setAuthentication(authentication);

Then Spring Security injects it here:

    public String currentUserName(Authentication authentication)

Inside this object, Spring now knows:
- ğŸ‘¤ Username
- ğŸ” Roles
- ğŸ« Authorities

â¡ï¸ No need to manually send Authentication.
â¡ï¸ Spring retrieves it from the SecurityContext for you.

----------------------------------------------------------------------------

ğŸ‘¥ **3. What if multiple users are logged in using cookies?**
----------------------------------------------------------------------------

No issue at all.

JWT-based auth is **stateless**, meaning:

âœ”ï¸ No global login
âœ”ï¸ No shared session
âœ”ï¸ No server-side tracking

Each browser/device has **its own JWT cookie**:

ğŸ§‘ User Aâ€™s browser â†’ cookie contains JWT for A
ğŸ‘© User Bâ€™s browser â†’ cookie contains JWT for B

Each request runs in its own thread:

â¡ï¸ Own SecurityContext
â¡ï¸ Own Authentication
â¡ï¸ Users do NOT interfere with each other

Even two tabs from the same user:
- Both send the same JWT cookie
- Both authenticate the same user

----------------------------------------------------------------------------

ğŸ§  **4. Key Insight**
----------------------------------------------------------------------------

Cookies **do NOT store login state**.
They only store the JWT token.

The **server recreates the login state on EVERY request** by:

1. Reading JWT
2. Validating it
3. Building Authentication
4. Filling SecurityContext

Stateless, clean, safe.

----------------------------------------------------------------------------

ğŸ“ Summary Table
----------------------------------------------------------------------------

| What you might think                          | What actually happens               |
|-----------------------------------------------|-------------------------------------|
| Cookies store logged-in user state            | âŒ No, only store JWT token         |
| Spring â€œremembersâ€ the login                  | âŒ No, stateless â€” no memory        |
| Authentication persists across requests       | âŒ No, rebuilt every request        |
| Filter sets Authentication â†’ Controller uses it | âœ”ï¸ Exactly how it works            |

----------------------------------------------------------------------------

