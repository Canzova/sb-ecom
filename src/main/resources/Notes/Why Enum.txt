â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ§© WHAT IS ENUM AND WHY WE USE IT IN OUR PROJECT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1ï¸âƒ£ BASIC IDEA OF ENUM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
An `enum` in Java (short for *enumeration*) is a **special data type**
that represents a fixed set of constant values.

Think of it like a list of predefined options that never change.

Example:
------------------------------------------------
public enum AppRole {
    ROLE_USER,
    ROLE_SELLER,
    ROLE_ADMIN
}
------------------------------------------------

This defines **three valid role types** that exist in your system â€” no more, no less.

âœ… So you can only use one of these roles:
- `AppRole.ROLE_USER`
- `AppRole.ROLE_SELLER`
- `AppRole.ROLE_ADMIN`

You CANNOT create or assign other values like "MODERATOR" unless you add it to the enum.


2ï¸âƒ£ WHY ENUM IS IDEAL FOR USER ROLES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
In your e-commerce app, users can have different roles with specific permissions:
- A **USER** can browse and buy products.
- A **SELLER** can upload and manage products.
- An **ADMIN** can manage users and the system.

You want to represent these roles in your Java code **safely and consistently**.

If you stored them as raw strings like `"user"`, `"admin"`, `"seller"`, you risk:
- Typos (`"admn"` instead of `"admin"`)
- Inconsistent capitalization (`"User"`, `"user"`, `"USER"`)
- Hard-to-maintain code

By using an enum:
- The compiler ensures correctness (no typos allowed)
- Code becomes self-documenting
- Easier role management and future updates


3ï¸âƒ£ HOW ENUM CONNECTS TO THE DATABASE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Your `Role` entity class looks like this:
------------------------------------------------
@Entity
@AllArgsConstructor
@NoArgsConstructor
@Data
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name="role_id")
    private Integer roleId;

    @Enumerated(EnumType.STRING)
    @Column(length = 20, name="role_name")
    private AppRole roleName;

    public Role(AppRole roleName) {
        this.roleName = roleName;
    }
}
------------------------------------------------

ğŸ‘‰ Breakdown:
- `private AppRole roleName;`
  â†’ The field type is the `enum` we created.
- `@Enumerated(EnumType.STRING)`
  â†’ Tells JPA to store the **enum name** as text in the DB.
  Example:
    | role_id | role_name   |
    |----------|-------------|
    | 1        | ROLE_USER   |
    | 2        | ROLE_SELLER |
    | 3        | ROLE_ADMIN  |

This makes the data both readable and safe.


4ï¸âƒ£ HOW ITâ€™S USED IN CODE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
When assigning roles to users, you use enum constants:

Example:
------------------------------------------------
Role userRole = new Role(AppRole.ROLE_USER);
Role adminRole = new Role(AppRole.ROLE_ADMIN);
------------------------------------------------

When saving these roles in the database, they become:
ROLE_USER, ROLE_ADMIN, etc.

When retrieving them back from the database, JPA automatically converts
the string "ROLE_USER" â†’ `AppRole.ROLE_USER` (enum object).

So you can use it directly in your logic:

------------------------------------------------
if (user.getRole().getRoleName() == AppRole.ROLE_ADMIN) {
    // allow admin-level access
}
------------------------------------------------


5ï¸âƒ£ ADVANTAGES OF USING ENUM FOR ROLES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… **Type Safety**
   Only predefined constants can be used (no invalid roles).

âœ… **Readability**
   `AppRole.ROLE_ADMIN` is much clearer than `"admin"`.

âœ… **Database Consistency**
   Every role stored will match exactly the enum names.

âœ… **Ease of Use in Logic**
   You can compare roles using `==` instead of string comparison.

âœ… **Centralized Role Management**
   All possible roles live in one place (`AppRole.java`),
   making it easy to add/remove roles later.


6ï¸âƒ£ FUTURE SCENARIO
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
If later your app adds a new type of user (for example, a "DELIVERY" role):

You simply add:
------------------------------------------------
ROLE_DELIVERY
------------------------------------------------
to the `AppRole` enum, and your system can start using it immediately
with full type safety and database integration.

No need to modify multiple classes or database scripts manually.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âœ… TL;DR SUMMARY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
| Concept | Description |
|----------|--------------|
| Enum | Represents a fixed set of constants (roles, statuses, etc.) |
| Why use it | Prevents typos, ensures safety, improves readability |
| With @Enumerated | Maps enum to readable DB values ("ROLE_USER") |
| Benefits | Type-safe, consistent, easy to manage and scale |
| Example in code | new Role(AppRole.ROLE_USER); |

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“˜ END OF ENUM EXPLANATION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
